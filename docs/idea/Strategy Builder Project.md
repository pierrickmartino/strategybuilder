# Product Requirements Document: Crypto Strategy Builder Web Application

## Overview and Objectives

This PRD outlines a web-based application that enables retail crypto traders to create, test, and deploy trading strategies through an intuitive visual interface. The goal is to **empower beginners** and non-programmers to participate in algorithmic trading by providing a no-code, drag-and-drop strategy builder . The product will launch with a **freemium model** to encourage wide adoption: a free tier offers basic functionality with limits, while a premium tier unlocks unlimited usage. Key objectives include:

- **Accessibility**: Lower the technical barrier for strategy automation (visual flowchart builder, no coding needed ) in line with industry trends of making advanced trading tools more accessible .
- **Risk-Free Experimentation**: Allow users to safely experiment using **strategy backtesting** on historical data and **paper trading** on live data, reducing the risk of untested strategies .
- **Comprehensive Trading Suite**: Provide an all-in-one platform with strategy design, performance analytics, and portfolio tracking, so users can design strategies, evaluate performance, and monitor their crypto holdings in one place.
- **Scalability and Reliability**: Design the system to handle many users and concurrent strategy executions with high uptime and data integrity (even in volatile markets) .

**Target Users**: Retail crypto traders (novice to intermediate) who want to automate strategies without coding, as well as advanced users who appreciate rapid strategy prototyping. The interface and features will be beginner-friendly, with tooltips and templates, but also flexible enough for experienced traders to customize logic.

## Platform & Tech Stack

The application will be delivered as a **web-only** platform (desktop browser access) with a modern tech stack to ensure performance, security, and ease of development:

- **Frontend**: Built with **Next.js (React)** and **TypeScript**, ensuring a fast and SEO-friendly single-page application. Styling will use **Tailwind CSS** for a responsive, mobile-friendly UI. The frontend will implement an interactive drag-and-drop infinite canvas for strategy building (using a library such as React Flow or similar for node-based diagrams). Full **internationalization (i18n)** support is required from the start – text strings will be externalized to enable easy localization of the UI into multiple languages.
- **Backend**: Implemented with **FastAPI (Python)**, chosen for its performance and intuitive design for building RESTful APIs. The backend will expose endpoints for all core functions (user auth, strategy CRUD operations, backtest execution, live trading control, wallet data fetching, etc.) and handle business logic securely on the server side. Python allows leveraging scientific libraries if needed for strategy computation.
- **Data & Integration**: Market data is sourced via **CCXT**, a widely used cryptocurrency exchange API library . CCXT will provide unified access to historical price data and live market feeds from exchanges (e.g. Binance or Coinbase) for assets like BTC, ETH, and MATIC/Polygon. It will enable both fetching OHLCV data for backtesting and live price updates for paper trading. No exchange account API keys are required for users at launch – all trading is simulated. For **wallet integration**, the app will connect via public blockchain APIs (e.g. Ethereum and Polygon RPC or third-party services) to retrieve balances and DeFi positions using **public wallet addresses** (similar to how portfolio trackers allow connecting by just inputting the address ). **No private keys** will ever be requested or stored – wallet access is read-only for tracking purposes.
- **Database**: A **PostgreSQL** database (or similar SQL database) will store user data, including account info, strategies, and results. Strategy definitions (the visual rules) can be stored as structured JSON or a custom schema. The DB will also hold backtest results and logs, user portfolio data (balances fetched for wallets), and subscription status (free/premium).
- **Server & Deployment**: The system should be containerized (Docker) for easy deployment. Next.js will be statically built or server-side rendered and served via Node.js. FastAPI will run behind a scalable application server (ASGI server like Uvicorn/Gunicorn). Both components can be deployed on cloud infrastructure (e.g. AWS, Azure, or GCP), with load balancing as needed. We will design the architecture to be horizontally scalable – multiple FastAPI instances handling different users’ strategy tasks, and background workers for heavy computations.

## Functional Requirements

### 1. Visual Strategy Builder

**Description**: A core feature is a **flowchart-style strategy editor** where users can visually define trading rules by dragging and connecting blocks. This no-code interface will let users create **algorithmic trading strategies without programming** . Key capabilities include:

- **Blocks & Connections**: Users can add “condition” blocks (e.g. price triggers, technical indicators, time-based triggers) and “action” blocks (e.g. buy/sell orders, alerts). Blocks can be connected to form logical flows (e.g. IF condition THEN action). For example, a user could set up a condition block checking “**BTC price crosses above 50-day moving average**” linked to an action block “**Buy 1 BTC**”. Multiple conditions can funnel into a single action (and vice versa) to create complex strategies.
- **Indicators & Parameters**: The builder will offer a library of common **technical indicators** (e.g. moving averages, RSI, MACD) and logical operators (greater than, less than, crosses, etc.). Users can configure parameters for each indicator block (for instance, set MA period to 50 days). Timeframe selection for indicators (1min, 1h, 1d candles, etc.) is supported.
- **Strategy Configuration**: In addition to entry/exit logic, users can define **risk management rules** within the strategy. For example, blocks for **stop-loss** (sell if price drops X% below entry) or **take-profit** (sell if profit is Y%) can be included. The visual builder should support embedding such risk parameters directly into the strategy flow . Position sizing (how much to buy/sell) can be set per action (fixed amount or percentage of portfolio for paper trading).
- **Usability Features**: The interface will be beginner-friendly: it should include pre-built example strategies/templates to get started, tooltips and help icons explaining each block’s function, and validation to prevent invalid configurations (e.g. unconnected blocks). Users can **save** a strategy (with a custom name) to their account. They can **edit** a saved strategy by returning to the builder, **clone** a strategy to use as a starting point for a new idea, or **delete** strategies they no longer need. The builder will also allow labeling blocks or adding brief notes so users can document their logic.
- **Execution Semantics**: The visual rules will be converted into an internal representation that the backend can execute. For example, a strategy might be represented as a JSON of conditions and actions. The system will ensure that strategies execute deterministically: e.g., checking all conditions in order on each time tick (minute) and triggering actions when conditions are met. Users do not need to worry about the underlying code – the system will translate the flowchart into the logic that runs the strategy.

**Acceptance Criteria**: Users can create a valid strategy using the visual editor and save it. The strategy should accurately represent the intended logic (no coding required) and be stored for use in backtesting or live trading. The UI should prevent or flag incomplete setups (such as an action block with no condition). On re-opening a saved strategy in the builder, it should display exactly as last configured for further editing.  

### 2. Backtesting Engine

**Description**: The platform provides a **backtesting** feature that lets users run their saved strategies against historical market data to evaluate performance. This helps users refine strategies by seeing how they would have performed in the past . Key requirements for backtesting:

- **Historical Data Source**: Backtests will use historical OHLCV price data obtained via the **CCXT** integration. At launch, the system will support backtesting on at least three major assets: **Bitcoin (BTC)**, **Ethereum (ETH)**, and **Polygon (MATIC)**. Users can select which asset (and possibly which exchange’s pricing) and a historical time range. Free users are limited to **1 month of historical data**, whereas premium users can backtest on a longer history (e.g. up to 1+ year or the maximum available). Data granularity will typically be 1-minute candles (to match the live trading granularity), though users might have an option to test on higher timeframes for speed.
- **Backtest Execution**: When a user initiates a backtest, the backend will fetch the required historical data (if not cached) and simulate the strategy’s logic over that data. The simulation will step through each time interval (minute by minute) and evaluate the strategy’s conditions, executing buy/sell actions whenever the conditions in the strategy are fulfilled. Trades will be simulated with an assumed initial capital (e.g. default $10,000 virtual portfolio, or user-specified) to track profits and losses. No actual orders are sent to any exchange – this is purely a computation.
- **Performance Metrics**: After the backtest completes, the user is presented with results and analytics. The UI will show summary **performance metrics** such as: **total return** (percentage gain/loss over the period), **win rate** (percentage of trades that were profitable), **maximum drawdown** (largest peak-to-trough drop in portfolio value), **Sharpe ratio** (risk-adjusted return measure), **profit factor** (total profit divided by total loss), and other relevant stats . For example, the user can see if their strategy had a 60% win rate and a Sharpe ratio of 1.2 – key indicators of performance and risk . We will also report the number of trades taken, average profit per trade, and possibly volatility of returns.
- **Results Visualization**: The backtest results page will include charts for deeper insight. A **equity curve** graph (portfolio value over time) will illustrate how the strategy’s capital grew or shrank during the test. Trades could be marked on a price chart (showing where buys and sells would have occurred). We will highlight notable events, such as the moment of maximum drawdown. Users should be able to scroll through trade logs – a chronological list of each simulated trade (buy/sell, amount, price, date/time, resulting balance).
- **Configuration Options**: Users can configure backtest parameters such as the time range, initial capital, and possibly trading fees assumptions or slippage (initially, we may assume zero fees for simplicity, or allow a fixed fee rate setting to simulate more realistic conditions). Premium users can access longer time ranges and maybe more granular configuration (like different assets or multiple assets if multi-asset strategies are later allowed).
- **Performance & Limits**: Backtests will run on the server side, and should complete in a reasonable time (a backtest on one month of minute data should finish within seconds to a few tens of seconds). To avoid overloading the system, free users might be limited in frequency of backtests (e.g. no more than X backtests per hour) or concurrency. The system might queue backtest jobs if too many are requested at once, and a loading/progress indicator will be shown to the user during the simulation.  

**Acceptance Criteria**: Users can select a strategy, choose an asset and historical period, and run a backtest. The system returns a detailed report with key metrics and charts. The metrics should make sense (e.g. no division-by-zero errors, Sharpe ratio is calculated if there’s variation in returns, etc.) and correspond to the strategy’s behavior. For a given fixed dataset, backtesting the same strategy should yield consistent results every time. Free user restrictions (1-month data, etc.) must be enforced by the backend.

### 3. Live Paper Trading  

**Description**: In addition to backtesting, users can deploy their strategy in **live paper trading mode**. This means the strategy will run on real-time market data without executing real trades – all trades are simulated (virtual portfolio), but using live prices. This feature allows users to forward-test their strategies in current market conditions and monitor performance as if they were trading, but with zero financial risk. Key aspects include:

- **Live Data Feed**: The system will use CCXT or exchange websockets to fetch live price updates for the supported assets. The trading logic will evaluate **in near real-time (with minute-level granularity)** – i.e., at the close of each one-minute interval (or whenever new minute candle data is available), the strategy conditions are evaluated. Using a one-minute tick ensures strategies act quickly enough for most retail trading needs while keeping load manageable. Since crypto markets operate 24/7, the system will continuously run strategies around the clock once deployed.
- **Strategy Execution Engine**: When a user activates paper trading for a strategy, the backend will start a dedicated **simulation process** for that strategy. This could be a background job that wakes up every minute, retrieves the latest price/market data for the asset, and runs the strategy’s logic for that interval. If a condition is met (e.g., “price crossed above X, trigger buy”), the engine will simulate an order execution: update the virtual portfolio by deducting cash and adding the asset at the current price. Similarly, sell conditions would deduct the asset and add cash. We will assume sufficient virtual capital or allow the user to specify a starting balance. All actions are **logged**.
- **Trade Logs and Monitoring**: Users need insight into what their live paper strategy is doing. The app will provide a **live dashboard view or log** for each running strategy, showing the latest status and actions. This might include a real-time feed of signals and trades (e.g., “09:31:00 - Bought 0.5 ETH at $1700”). The user’s virtual portfolio value for that strategy is updated with each trade, and basic performance stats (P/L, return, win rate of closed trades, etc.) are calculated on the fly. Graphs similar to backtesting (equity curve) can show the strategy’s performance since it was started in paper mode.
- **Multi-Strategy Management**: On the backend, multiple strategies from possibly many users will be running concurrently. The architecture should support **hundreds of users each running one or more strategies simultaneously**. To handle this, efficient scheduling or asynchronous processing is required. For example, we might maintain a scheduler that triggers all active strategies every minute (batch processing) rather than hundreds of independent timers. The design will ensure minimal latency so that all strategies evaluate promptly when new data comes in, preserving the real-time aspect. Scalability is key: as user count grows, we may distribute strategy execution across multiple worker processes or servers. The system will be tested to handle the target load (e.g. 100s of strategies per minute) without significant delays.
- **Controls & Fail-safes**: Users can **start**, **pause**, or **stop** a paper trading session for a strategy at any time. For instance, after deploying a strategy, a user might pause it to make edits or stop it if they’re unsatisfied with performance. The UI will provide controls to manage this. The backend should handle these commands by starting or halting the associated background job. Additionally, there will be fail-safes: if the system misses data or an error occurs, it should not execute false trades. We will implement basic risk checks – e.g., not allowing a strategy to enter an absurd position due to glitch (perhaps by bounding trades or requiring price confirmation). In case of any system downtime, strategies resume or users are alerted. The reliability of continuous strategy execution is a priority (as highlighted by the need for operational consistency even during volatile markets ).

**Acceptance Criteria**: A user can take any saved strategy and activate live paper trading. The strategy then begins processing live data and the user can observe its actions on the dashboard. If the strategy’s entry conditions happen to be met in the market, the system logs a simulated trade. The virtual portfolio updates correctly (cash/asset balances change). The user can pause or stop the strategy, and the system stops simulating further trades for it. The one-minute update cycle should operate seamlessly, and performance metrics on the fly should match the trades made (for example, if only one trade was made and it’s winning, win rate shows 100%). Free-tier limitations (only 1 active strategy at a time for free users) will be enforced here.

### 4. Wallet Integration (Read-Only)  

**Description**: The application will allow users to **connect their cryptocurrency wallets** for portfolio tracking purposes. This is a **read-only wallet integration** meant to display the user’s holdings and DeFi positions on the dashboard, helping users see their overall portfolio performance alongside strategy results. Key details:

- **Supported Wallets/Networks**: At launch, we will support connecting **Ethereum wallets** (e.g. MetaMask or any Ethereum address), **Polygon (Matic)** addresses, and **Bitcoin** wallets. For Ethereum and Polygon, users will typically connect via an address (or ENS name) – the system will then fetch their token balances and possibly basic DeFi positions on those chains. For Bitcoin, users provide a BTC wallet address (or extended public key for more advanced tracking) and the system will fetch the balance for that address. The connection flow will be simple: the user enters or selects the chain, inputs their **public wallet address**, and the app saves it for tracking (similar to inputting an address in popular portfolio trackers ). Optionally, for Ethereum/Polygon we might use WalletConnect to let users easily select their address (signing in with a wallet), but **no private keys are ever requested or stored**.
- **Data Retrieval**: Once a wallet is connected, the backend will use appropriate APIs to fetch data. For Ethereum/Polygon, this could involve calls to a blockchain indexer or a service like Etherscan/Covalent to get the address’s token balances and possibly any liquidity pool or staking positions (if feasible). Initially, the focus is on **balances of main tokens** (e.g. ETH, MATIC, and popular ERC-20 tokens in that wallet) and **perhaps NFTs or DeFi assets in a simplified form**. For Bitcoin, an API (or CCXT if using an exchange’s data) will fetch the UTXO balance for the address. The data will be periodically refreshed (e.g. every few minutes or on-demand when user opens dashboard) to keep the portfolio info up to date.
- **Display & Portfolio Summary**: The **dashboard** (see next section) will show a summary of each connected wallet: total balance in terms of a base currency (e.g. total value in USD), and breakdown by asset. For example, if a user connects an Ethereum wallet, the dashboard might show “Wallet 1: $5,000 total – 1.2 ETH, 300 MATIC, 0.5 WBTC, …”. If possible, we’ll also display DeFi positions (e.g. “Staked 100 MATIC in Polygon PoS”). This gives the user a holistic view of their holdings. We will clarify that this is **for tracking only** – users cannot execute trades or transfers from our platform. The wallet integration is purely so they can monitor their portfolio performance.
- **Security & Privacy**: Since only public addresses are used, the security risk is low. However, we treat this data as sensitive: the backend will store addresses securely linked to the user account. We will not expose the address to other users (unless the user explicitly shares it). We also ensure that when fetching wallet data, we do so over secure APIs and do not mix data between users. Additionally, if a user removes a wallet from our app, we delete the stored address and cease tracking it.
- **Free vs Premium**: Free users can connect up to **1 wallet**. **Premium users** are allowed to connect multiple wallets (exact number can be unlimited or a high limit). On the UI, a free user attempting to add a second wallet will be prompted to upgrade. The backend will enforce this by checking the count of wallets associated with the account.

**Acceptance Criteria**: A user can add a wallet by inputting a public address (or connecting via wallet tool if available). The system confirms the addition and then displays the wallet’s balances on the dashboard, typically within a few seconds. The values displayed should match the actual on-chain balances for that address (verified against a blockchain explorer if needed). The user can see their wallet’s total value and individual assets. If the user removes the wallet or logs out, no sensitive data remains (only public info was used). Free users cannot add more than one wallet – the UI should prevent it and the backend will reject additional adds for safety.

### 5. User Dashboard

**Description**: The application will feature a **dashboard** as the main landing page once a user logs in. This dashboard provides an overview of the user’s strategies and connected wallets, acting as a command center for monitoring performance and accessing features. Key elements to include on the dashboard:

- **Strategy Summary**: A section listing all of the user’s strategies with key info at a glance. For each strategy, show its name, its current status (e.g. Active (Paper Trading) or Idle if not currently running), and a brief performance summary. The performance summary could differ based on context – if the strategy has backtest results, it might show the last backtest ROI or win rate; if it’s currently running in paper mode, it could show current paper P/L or last trade result. We might use a simple **traffic light indicator** or badge to denote status (green = running, grey = stopped). Users should be able to click on a strategy in the list to drill down into details (opening either the strategy editor for editing or a results page). There should also be buttons or links to quickly **start/pause/stop** paper trading on a strategy right from the dashboard, as well as to initiate a backtest.
- **Portfolio Summary**: A section that aggregates info from connected wallets. If the user has one wallet (free tier), it will show that wallet’s total value and perhaps a pie chart or list of top holdings. If multiple wallets (premium), it could show a combined total value across all wallets and allow the user to expand each wallet for details. The dashboard might show something like “Total Portfolio Value: $10,500 (Wallet1: $6,000 + Wallet2: $4,500)” and list major assets. This gives users a quick view of their overall crypto net worth and exposure.
- **Recent Activity Feed**: To make the dashboard lively, include a feed of recent relevant events. For example, “Strategy Alpha: Backtest completed – 12% return over 1 month” or “Strategy Beta: Bought 0.5 BTC in paper trading at $30,000” or “Wallet1: New deposit of 0.1 ETH detected”. This feed provides real-time feedback and keeps users engaged with updates from their strategies and wallets.
- **Educational / Upgrade Banners**: Because the app targets beginners, the dashboard can also gently surface educational tips or call-to-action. For instance, if the user hasn’t run a backtest yet, a tip could say “Try backtesting your strategy to see historical performance.” If the user is free tier, an unobtrusive banner might highlight benefits of premium (“Upgrade to Premium for unlimited strategies and longer backtests”). These should not clutter the interface but serve as guidance.
- **Navigation**: The dashboard will serve as the hub from which users can navigate to other sections: a prominent button to “Create New Strategy” (launching the visual builder), a link to “View All Strategies” (if we have a dedicated page), and possibly a “Wallets” section where they can manage connected wallets (add/remove). The design should ensure users can easily find and use all major features from this main page.

**Acceptance Criteria**: Upon login, users land on a dashboard page that correctly reflects their data. If a user has saved strategies, they are all listed with correct statuses and data (e.g. a just-run backtest’s results). If a strategy is active in paper trading, the dashboard updates its status in near real-time (perhaps with use of WebSocket or periodic refresh). Connected wallet balances shown should match what’s in the wallet integration. All actions (e.g. clicking “start” on a strategy, or “new strategy”) function and navigate appropriately. The UI should remain clear and not overwhelming – information is organized under clear headings (Strategies, Portfolio, etc.).

### 6. Authentication & User Roles

**Description**: The application will include a secure authentication system and support two primary user roles/tiers (Free and Premium). It’s essential to manage sign-ups, logins, and access control for features based on the user’s plan. Key requirements:

- **User Registration & Login**: Users can **sign up** with email and password, or use third-party login options for convenience. We will integrate **Google OAuth** for one-click sign in with Google accounts. Additionally, we plan to support **Web3 wallet login** – a user can authenticate by connecting a crypto wallet (like MetaMask) and signing a message to prove ownership, which creates/links to an account. This provides a passwordless login method popular in crypto apps. Regardless of method, the user must then have a profile in our database. Standard security practices apply: passwords are hashed, OAuth tokens are handled securely, etc. There will be **email verification** for email sign-ups and possibly CAPTCHA to prevent bot accounts.
- **User Roles/Tiers**: At account creation, a user is assigned the **Free tier** by default. We will have an internal flag or field indicating if a user is Premium (paid). Premium status might come from a subscription purchase (handled outside this PRD scope, but assume we have a subscription system or manual admin upgrade). The backend will implement **role-based access control** checks on relevant endpoints to enforce limits. Specifically:  

	- **Free Tier Capabilities**: Limited to **1 active strategy** (they can create only one strategy in their library), **1 connected wallet**, and **historical data up to 1 month in backtesting**. They can still run that one strategy in paper trading but cannot deploy multiple simultaneously. If they try to create a second strategy, the system will prevent it (UI can show an upgrade prompt). If they try to backtest beyond 1 month or fetch data beyond limit, the API will return an error or truncated data.
	- **Premium Tier Capabilities**: **Unlimited strategies** (or a reasonably high limit like 50+ if needed for system safety), **multiple wallets** (we will allow perhaps up to 10 or unlimited as long as performance holds), and extended backtesting history (e.g. several years of data if available). Premium users can run multiple strategies in paper trading at once. Essentially, all core features are unlimited for premium within fair use.

 - **Account Management**: Users can manage their account info via a settings page – change password, link/unlink Google or wallet, etc. They should also see their current plan and if not premium, have the option to upgrade (this might redirect to a payment page). The system should handle logging out (clearing sessions). We will use secure session management or JWT tokens for API authentication. If JWT, then role info can be encoded or checked against DB on each request.
- **Admin Considerations**: (Internal) We may have an admin role to manage users, but for this PRD it’s not a priority. Still, we will design the database to flag admin accounts, and possibly an admin panel for managing subscriptions or content could be added later.

**Acceptance Criteria**: A new user can register and then log in successfully. Logging in creates a session (or returns an auth token) and they can access their dashboard. Google login works (if configured) for users who choose it. If wallet login is used, the user is prompted to connect their wallet and sign a random nonce message; after which an account is either created or retrieved and the user is logged in. Role enforcement: a free user is indeed prevented from exceeding limits (try to add second strategy -> gets an upgrade prompt, etc.). A premium user (we can simulate by marking an account as premium in DB) can utilize unlimited features. Security: ensure a logged-out user cannot access protected endpoints (e.g., backtesting API) without authentication. Password resets and email verification flows (if applicable) should work as expected (these may be handled by sending emails via backend).  

### 7. Strategy Sharing

**Description**: To encourage collaborative learning and community, the platform will include a **strategy sharing** feature. This allows a user to share one of their strategies with another user (or anyone) in a controlled manner. As this is a potentially sensitive feature (strategies could be proprietary), sharing will be **opt-in and private by default** – only people with the link or explicit access can view the strategy. Key points:

- **Private Link Sharing**: A user can choose to generate a **shareable link** for a specific strategy they created. The app will create a unique URL (with a GUID or token that’s hard to guess). Anyone with this URL can view a **read-only** version of the strategy (the flowchart and details), even without logging in. However, to copy or use the strategy, the viewer would need to log in and save it to their account (if they have an account). This way, a user can send their strategy to a friend by just sharing the link. The strategy remains **unlisted** (not publicly browsable on the platform without the link). The owner can revoke the link (which invalidates that URL).
- **User-to-User Sharing**: Alternatively (or in addition), a user may share directly with another user by username or email. For example, Alice can share her strategy “GoldenCrossBot” with Bob’s account by specifying Bob’s username. Bob would then get a notification or see the shared strategy in a “Shared with me” section. This approach keeps it between specified parties. Bob could then clone the strategy into his own workspace (creating his editable copy) or run it as shared if we allow that. Initially, simplest implementation is to just allow link sharing (which covers this if Bob gets the link).
- **Viewing Shared Strategies**: When accessing a shared strategy link, the system will present a **strategy detail page** showing the strategy name, description (if the creator provided one), and the visual diagram of the logic. If the viewer is logged in, they should have an option “Clone to My Strategies” which will save a duplicate under their account (they become the owner of the new copy). If the viewer is not logged in, they’ll be prompted to sign up or log in to save the strategy. We will not expose the sharer’s personal info other than maybe their username or a display name, with their consent.
- **Privacy & Permissions**: By default, strategies are private to each user. Sharing is only done when the user takes explicit action to generate a link or invite a user. We’ll include reminders in the UI (e.g., “Anyone with this link can view your strategy logic. They cannot see your backtest results or run it unless they save a copy.”). The owner retains control: they can disable sharing at any time (which should invalidate any links and remove others’ access). If a user clones someone’s shared strategy, that clone is fully theirs and not affected by the original owner later revoking access (since the clone is a separate entity).
- **No Public Marketplace** **(at Launch)**: Notably, this feature is meant for private sharing and collaboration, not an open marketplace. We are not launching a public library of strategies for browsing. (However, this lays groundwork for a potential future feature where users could publish strategies for everyone or even sell them – but that is out-of-scope for the initial version.)

**Acceptance Criteria**: A user can share a strategy and another user (or an anonymous person with the link) can access the shared strategy view. The logic and details of the strategy are displayed read-only; the viewer cannot edit the original. If the viewer is logged in, they can successfully clone the strategy to their account and then edit or use it like any other strategy. If the original owner revokes a share, the link should no longer function (visiting it could show an error that the strategy is no longer shared). Permissions should be such that only the intended shared content is visible – e.g., the viewer should not see anything else about the owner’s account or other strategies.  

## Technical Architecture

This section outlines the proposed architecture and technical considerations for implementing the above features. The system is split into a client-side frontend and a server-side backend, with clear API contracts between them. 

- **Frontend (Next.js + TypeScript)**: The Next.js app will serve the user interface and handle all client-side interactions. It will use React for dynamic components – particularly the **Visual Strategy Builder** canvas. We will likely integrate a library (e.g. **React Flow** or **JointJS**) to manage the flowchart UI, allowing draggable nodes, connectors, and a state representation of the strategy. State management can be handled via React Context or a state library (like Redux or Zustand) especially to manage strategy state and user data globally. Pages in the app include: Dashboard, Strategy Builder/Editor, Backtest Results, Strategy Detail/Share view, Profile/Settings, etc. Next.js will also help with server-side rendering for initial loads and can be deployed easily on platforms like Vercel for scalability. TailwindCSS will ensure we have a consistent design system with utility classes – speeding up UI development and making it easy to apply responsive styles for different screen sizes. The frontend will communicate with the backend via REST API calls (using fetch/Axios) and possibly WebSockets for live updates (e.g. receiving real-time trade log updates for paper trading, if we push events from server). For localization, we will use Next.js internationalization routing or a library like next-i18next: all text will be in JSON resource files for each language. We plan to launch with at least English, but the system will be ready to add other languages. Users can select their language, or it can auto-detect browser language.
- **Backend (FastAPI + Python)**: The FastAPI backend will handle all business logic, persistence, and integrations. We will structure it with multiple routers or modules corresponding to features:  

	- **Auth Module**: Endpoints for register, login (email/pw), OAuth callback for Google, wallet-signature verification for wallet login. It will issue JWT tokens for authenticated sessions or use server-side sessions. This module also manages password reset, email verification, etc. Role checking (free vs premium) is done here or via dependency in FastAPI routes.
	- **Strategy Module**: Endpoints to **create, read, update, delete (CRUD)** strategies. A strategy consists of its metadata (name, owner, created date, etc.) and the logic definition (which could be JSON describing the nodes and connections). When a user saves a strategy from the frontend, it calls an API like POST /strategies with the strategy definition. Likewise, GET /strategies returns the list of user’s strategies (for dashboard).
	- **Backtest Module**: Endpoint to trigger a backtest run, e.g. POST /backtest with parameters (strategy_id, asset, start_date, end_date, initial_capital, etc.). This will enqueue or start a backtesting job. Possibly, to avoid the request timing out, the request could immediately return a job ID and we use WebSocket or polling to get results when ready. However, for simplicity, if backtests are quick (for 1 month data) we might do it synchronously and return the results in the response. The backtest logic will utilize CCXT to fetch historical OHLCV data (e.g., if asset=BTC and exchange=Binance, call CCXT fetchOHLCV for that pair and period). The data will be loaded into a pandas DataFrame or similar for simulation. The strategy logic (conditions/actions) will be interpreted – perhaps by converting the visual blocks into a Python code or by having a predefined set of possible conditions we can evaluate. We will implement a small engine that takes the strategy definition and iterates through each time tick, evaluating conditions and tracking positions. After simulation, it computes the metrics (Sharpe, win rate, etc.). We may use libraries (numpy/pandas for calc, or talib for indicators) to assist. The results are then returned or stored. The endpoint will return the metrics and trade log to the frontend.
	- **Live Trading Module**: Endpoints to start/stop a paper trading strategy, e.g. POST /papertrading/start with strategy_id, and POST /papertrading/stop. Starting will register the strategy in a live trading scheduler. This could be implemented using a background task (e.g. FastAPI’s background_tasks or a separate **Celery worker** for more robust scheduling). We may maintain an in-memory or database table of active strategies. Each strategy will have its state (current virtual portfolio, last run time, etc.). The pricing feed can be handled either by polling in each task (each minute fetch price via CCXT) or by a global scheduler that distributes prices. We might also consider using WebSockets if available for live prices (some exchanges provide websockets for live ticker data). Given moderate scale, a simpler approach is to poll every minute via CCXT REST API for required markets. The engine for paper trading will reuse much of the backtest logic but in an incremental way (each minute, run one step of the strategy). The backend also needs to send updates back to the client – possibly we provide an endpoint for fetching the latest status, but a better UX is to use WebSocket push or Server-Sent Events to update the frontend dashboard logs in real-time. FastAPI can integrate with WebSocket routes for this purpose.
	- **Wallet Module**: Endpoints to add/remove a wallet and to fetch its balances. E.g., POST /wallets with address & type, which stores it for the user (after validation), and GET /wallets to list saved wallets with their latest balances. To fetch balances, the backend might call out to external APIs. For Ethereum/Polygon, one approach is using a library like web3.py to query the blockchain (though that requires an RPC node or Infura). Alternatively, use a service API like Etherscan (which has an API to get address balance and token holdings). For Bitcoin, use a block explorer API or bitcoin library if a full node is not feasible. The data is then normalized (list of assets and balances) and returned. We will cache this data for short periods to avoid hitting rate limits – e.g., refresh when user opens dashboard or manually refreshes.
	- **Metrics & Logging**: The backend will also be responsible for logging important events (for debugging and audit). For example, every trade executed in paper trading can be logged to a DB table for historical record (especially for premium users who might want to analyze past runs). Error handling is crucial – if a strategy evaluation fails (bug in logic or data fetch fail), the system should catch exceptions and perhaps pause that strategy and alert the user with an error message.

- **Scalability & Performance**: From the start, we design for scale. FastAPI is asynchronous, which helps in handling I/O-bound tasks like calling external APIs (CCXT, blockchain APIs) concurrently. We will likely use asynchronous calls for data fetching to not block the event loop. However, CPU-intensive tasks like running a large backtest or computing many strategies each minute might need to be offloaded to background workers or separate processes so as not to block API responsiveness. We may integrate a **task queue system (Celery or RQ)** with a Redis or RabbitMQ broker to handle backtest jobs and possibly live trading ticks. For example, when a strategy is set to live, a Celery task could be scheduled every minute for it. If the volume is high, a more efficient method is to have a single scheduler task that publishes a tick event each minute that workers subscribe to. These are implementation details to refine, but the architecture will allow distributing load. We also ensure that read/write to the database are optimized (use indexes, avoid heavy transactions in the minute loop, etc.). Static assets (frontend) will be CDN-cached. Horizontal scaling is achieved by running multiple instances of the FastAPI app behind a load balancer – since user sessions are stateless (with JWT) or sticky sessions, this is straightforward. The database can be a single instance to start, but for high scale we might consider read replicas or a hosted solution that scales. We will also set up monitoring (application performance monitoring, logging) to keep track of performance and errors, ensuring reliability for users.
- **Security Considerations**: Security is paramount given this involves financial data (though no actual trading). All API endpoints will require proper authentication (except maybe the strategy sharing view which might be a special case with a token in the URL). Data in transit will be encrypted (HTTPS for all requests). We will implement input validation on all APIs (e.g., strategy definitions should be validated to prevent code injection or malicious content). Rate limiting may be applied to prevent abuse (for instance, avoid someone spamming backtest requests). As mentioned, **no private keys** are ever stored or asked for, reducing a major security risk. Passwords are hashed (using bcrypt or argon2). For wallet addresses, we will validate format to ensure they are legitimate addresses to avoid storing arbitrary data. The system will also comply with privacy standards – e.g., allowing users to delete their account and associated data. We will log user activity that’s relevant (like logins, strategy runs) for auditing and have alerts for unusual activity (like a single user making excessive requests).
- **Localization**: The technical setup for localization involves maintaining resource files for each supported language on the frontend. We will use language keys in the UI components. The backend will be largely language-agnostic (sending data), but if any messages or emails are sent to users, those should be localized as well. For example, if we send a confirmation email or an error message from the API, we might use a localization library in Python or simply send generic messages for now. Testing will ensure that adding a new language is as easy as adding new translation files and that text expansion doesn’t break layouts.
- **Testing and Quality**: We will employ both unit tests and integration tests. For example, we’ll write tests for the backtesting calculation (feed a known price series and strategy and verify the outcome metrics). We’ll also test the API endpoints for proper authorization and limit enforcement. Frontend testing can include Jest/React Testing Library for critical components (like the strategy builder logic). Before launch, we’ll run a beta with a small set of users to gather feedback, especially on usability for beginners and to catch any edge-case bugs in the trading logic.
- **Deployment & DevOps**: For a production-ready system, we will set up CI/CD pipelines. Each commit can run tests and on merge, deploy to a staging environment. From there we can deploy to production. We’ll also use container orchestration (like Kubernetes or a platform like AWS ECS) to manage scaling the services. Environment variables or a secure vault will be used for secrets (DB passwords, API keys for external services like Etherscan). Logging and monitoring services (like CloudWatch, Sentry, or NewRelic) will be integrated to quickly spot issues in production.

In summary, the technical architecture is designed to be robust and scalable, using modern frameworks (FastAPI, Next.js) and proven libraries (CCXT for exchange data ) to implement the required functionality. The system will handle real-time aspects of trading simulation and provide a smooth experience to users, while maintaining security and flexibility for future growth.

## Conclusion and Future Considerations

This PRD has detailed the vision and requirements for the Crypto Strategy Builder web application. By combining a user-friendly visual rule builder with powerful backtesting and paper trading capabilities, the product aims to fill the gap for retail traders who want algorithmic trading tools without the complexity. All features from strategy creation, analysis of results, to portfolio tracking are integrated in one platform for convenience. The freemium model will help onboard users quickly, offering value in the free tier and advanced capabilities in the premium tier to monetize the platform.

**Future Features (Post-MVP)**: Although not in the initial scope, the architecture leaves room for expansion. In the future, we could integrate **live trading with real exchange APIs** (allowing users to connect exchange accounts via API keys to execute real trades once they are comfortable). We could also build a **strategy marketplace** where users can publish strategies publicly or even sell subscriptions to their strategies (taking the private sharing feature to a commercial level). Additional analytics like **strategy optimization tools**, more backtest metrics (e.g. Sortino ratio, etc.), and support for more assets and exchanges can be added. Mobile support (native app or responsive design improvements) could broaden accessibility.

For now, this document serves as a blueprint for development, ensuring that each team (frontend, backend, data) understands the requirements and how the pieces fit together. By adhering to these specifications, we aim to deliver a high-quality, production-ready application that provides retail traders with a professional-grade strategy automation experience – **“algorithmic trading for everyone,” visually and intuitively** .

**Sources**: The design and requirements have been informed by current industry trends and best practices, including the move toward no-code trading tools , the importance of backtesting to validate strategies , key performance metrics for evaluating algorithmic strategies , and secure integration with crypto data sources and wallets . These references underscore the feasibility and relevance of the features in this PRD. The development team should refer to them for deeper context as needed, while building the product to meet the outlined requirements.

#strategybuilder 